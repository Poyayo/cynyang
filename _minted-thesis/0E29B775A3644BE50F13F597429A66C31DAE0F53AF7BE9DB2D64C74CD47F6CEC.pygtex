\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{svoid}\PYG{+w}{ }\PYG{n+nf}{page\PYGZus{}dir\PYGZus{}activate}\PYG{p}{(}\PYG{k}{struct}\PYG{+w}{ }\PYG{n+nc}{task\PYGZus{}struct}\PYG{o}{*}\PYG{+w}{ }\PYG{n}{p\PYGZus{}thread}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{c+cm}{/********************************************************}
\PYG{c+cm}{ * 执行此函数时,当前任务可能是线程。}
\PYG{c+cm}{ * 之所以对线程也要重新安装页表, 原因是上一次被调度的可能是进程,}
\PYG{c+cm}{ * 否则不恢复页表的话,线程就会使用进程的页表了。}
\PYG{c+cm}{ ********************************************************/}

\PYG{c+cm}{/* 若为内核线程,需要重新填充页表为0x100000 */}
\PYG{+w}{   }\PYG{k+kt}{uint32\PYGZus{}t}\PYG{+w}{ }\PYG{n}{pagedir\PYGZus{}phy\PYGZus{}addr}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mh}{0x100000}\PYG{p}{;}\PYG{+w}{  }\PYG{c+c1}{// 默认为内核的页目录物理地址,也就是内核线程所用的页目录表}
\PYG{+w}{   }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{p\PYGZus{}thread}\PYG{o}{\PYGZhy{}\PYGZgt{}}\PYG{n}{pgdir}\PYG{+w}{ }\PYG{o}{!=}\PYG{+w}{ }\PYG{n+nb}{NULL}\PYG{p}{)}\PYG{+w}{	}\PYG{p}{\PYGZob{}}\PYG{+w}{    }\PYG{c+c1}{// 用户态进程有自己的页目录表}
\PYG{+w}{      }\PYG{n}{pagedir\PYGZus{}phy\PYGZus{}addr}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{addr\PYGZus{}v2p}\PYG{p}{((}\PYG{k+kt}{uint32\PYGZus{}t}\PYG{p}{)}\PYG{n}{p\PYGZus{}thread}\PYG{o}{\PYGZhy{}\PYGZgt{}}\PYG{n}{pgdir}\PYG{p}{);}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}

\PYG{+w}{   }\PYG{c+cm}{/* 更新页目录寄存器cr3,使新页表生效 */}
\PYG{+w}{   }\PYG{k}{asm}\PYG{+w}{ }\PYG{k}{volatile}\PYG{+w}{ }\PYG{p}{(}\PYG{l+s}{\PYGZdq{}movl \PYGZpc{}0, \PYGZpc{}\PYGZpc{}cr3\PYGZdq{}}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}r\PYGZdq{}}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{pagedir\PYGZus{}phy\PYGZus{}addr}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}memory\PYGZdq{}}\PYG{p}{);}
\PYG{p}{\PYGZcb{}}

\PYG{c+cm}{/* 击活线程或进程的页表,更新tss中的esp0为进程的特权级0的栈 */}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{process\PYGZus{}activate}\PYG{p}{(}\PYG{k}{struct}\PYG{+w}{ }\PYG{n+nc}{task\PYGZus{}struct}\PYG{o}{*}\PYG{+w}{ }\PYG{n}{p\PYGZus{}thread}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{n}{ASSERT}\PYG{p}{(}\PYG{n}{p\PYGZus{}thread}\PYG{+w}{ }\PYG{o}{!=}\PYG{+w}{ }\PYG{n+nb}{NULL}\PYG{p}{);}
\PYG{+w}{   }\PYG{c+cm}{/* 击活该进程或线程的页表 */}
\PYG{+w}{   }\PYG{n}{page\PYGZus{}dir\PYGZus{}activate}\PYG{p}{(}\PYG{n}{p\PYGZus{}thread}\PYG{p}{);}

\PYG{+w}{   }\PYG{c+cm}{/* 内核线程特权级本身就是0,处理器进入中断时并不会从tss中获取0特权级栈地址,故不需要更新esp0 */}
\PYG{+w}{   }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{p\PYGZus{}thread}\PYG{o}{\PYGZhy{}\PYGZgt{}}\PYG{n}{pgdir}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{c+cm}{/* 更新该进程的esp0,用于此进程被中断时保留上下文 */}
\PYG{+w}{      }\PYG{n}{update\PYGZus{}tss\PYGZus{}esp}\PYG{p}{(}\PYG{n}{p\PYGZus{}thread}\PYG{p}{);}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{c+cm}{/* 创建页目录表,将当前页表的表示内核空间的pde复制,}
\PYG{c+cm}{ * 成功则返回页目录的虚拟地址,否则返回\PYGZhy{}1 */}
\PYG{k+kt}{uint32\PYGZus{}t}\PYG{o}{*}\PYG{+w}{ }\PYG{n+nf}{create\PYGZus{}page\PYGZus{}dir}\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}

\PYG{+w}{   }\PYG{c+cm}{/* 用户进程的页表不能让用户直接访问到,所以在内核空间来申请 */}
\PYG{+w}{   }\PYG{k+kt}{uint32\PYGZus{}t}\PYG{o}{*}\PYG{+w}{ }\PYG{n}{page\PYGZus{}dir\PYGZus{}vaddr}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{get\PYGZus{}kernel\PYGZus{}pages}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{);}
\PYG{+w}{   }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{page\PYGZus{}dir\PYGZus{}vaddr}\PYG{+w}{ }\PYG{o}{==}\PYG{+w}{ }\PYG{n+nb}{NULL}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{n}{console\PYGZus{}put\PYGZus{}str}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}create\PYGZus{}page\PYGZus{}dir: get\PYGZus{}kernel\PYGZus{}page failed!\PYGZdq{}}\PYG{p}{);}
\PYG{+w}{      }\PYG{k}{return}\PYG{+w}{ }\PYG{n+nb}{NULL}\PYG{p}{;}
\PYG{+w}{   }\PYG{p}{\PYGZcb{}}

\PYG{c+cm}{/************************** 1  先复制页表  *************************************/}
\PYG{+w}{   }\PYG{c+cm}{/*  page\PYGZus{}dir\PYGZus{}vaddr + 0x300*4 是内核页目录的第768项 */}
\PYG{+w}{   }\PYG{n}{memcpy}\PYG{p}{((}\PYG{k+kt}{uint32\PYGZus{}t}\PYG{o}{*}\PYG{p}{)((}\PYG{k+kt}{uint32\PYGZus{}t}\PYG{p}{)}\PYG{n}{page\PYGZus{}dir\PYGZus{}vaddr}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+m+mh}{0x300}\PYG{o}{*}\PYG{l+m+mi}{4}\PYG{p}{),}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{uint32\PYGZus{}t}\PYG{o}{*}\PYG{p}{)(}\PYG{l+m+mh}{0xfffff000}\PYG{o}{+}\PYG{l+m+mh}{0x300}\PYG{o}{*}\PYG{l+m+mi}{4}\PYG{p}{),}\PYG{+w}{ }\PYG{l+m+mi}{1024}\PYG{p}{);}
\PYG{c+cm}{/*****************************************************************************/}

\PYG{c+cm}{/************************** 2  更新页目录地址 **********************************/}
\PYG{+w}{   }\PYG{k+kt}{uint32\PYGZus{}t}\PYG{+w}{ }\PYG{n}{new\PYGZus{}page\PYGZus{}dir\PYGZus{}phy\PYGZus{}addr}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{addr\PYGZus{}v2p}\PYG{p}{((}\PYG{k+kt}{uint32\PYGZus{}t}\PYG{p}{)}\PYG{n}{page\PYGZus{}dir\PYGZus{}vaddr}\PYG{p}{);}
\PYG{+w}{   }\PYG{c+cm}{/* 页目录地址是存入在页目录的最后一项,更新页目录地址为新页目录的物理地址 */}
\PYG{+w}{   }\PYG{n}{page\PYGZus{}dir\PYGZus{}vaddr}\PYG{p}{[}\PYG{l+m+mi}{1023}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{new\PYGZus{}page\PYGZus{}dir\PYGZus{}phy\PYGZus{}addr}\PYG{+w}{ }\PYG{o}{|}\PYG{+w}{ }\PYG{n}{PG\PYGZus{}US\PYGZus{}U}\PYG{+w}{ }\PYG{o}{|}\PYG{+w}{ }\PYG{n}{PG\PYGZus{}RW\PYGZus{}W}\PYG{+w}{ }\PYG{o}{|}\PYG{+w}{ }\PYG{n}{PG\PYGZus{}P\PYGZus{}1}\PYG{p}{;}
\PYG{c+cm}{/*****************************************************************************/}
\PYG{+w}{   }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{page\PYGZus{}dir\PYGZus{}vaddr}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+cm}{/* 创建用户进程虚拟地址位图 */}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{create\PYGZus{}user\PYGZus{}vaddr\PYGZus{}bitmap}\PYG{p}{(}\PYG{k}{struct}\PYG{+w}{ }\PYG{n+nc}{task\PYGZus{}struct}\PYG{o}{*}\PYG{+w}{ }\PYG{n}{user\PYGZus{}prog}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{n}{user\PYGZus{}prog}\PYG{o}{\PYGZhy{}\PYGZgt{}}\PYG{n}{userprog\PYGZus{}vaddr}\PYG{p}{.}\PYG{n}{vaddr\PYGZus{}start}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{USER\PYGZus{}VADDR\PYGZus{}START}\PYG{p}{;}
\PYG{+w}{   }\PYG{k+kt}{uint32\PYGZus{}t}\PYG{+w}{ }\PYG{n}{bitmap\PYGZus{}pg\PYGZus{}cnt}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{DIV\PYGZus{}ROUND\PYGZus{}UP}\PYG{p}{((}\PYG{l+m+mh}{0xc0000000}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{n}{USER\PYGZus{}VADDR\PYGZus{}START}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{/}\PYG{+w}{ }\PYG{n}{PG\PYGZus{}SIZE}\PYG{+w}{ }\PYG{o}{/}\PYG{+w}{ }\PYG{l+m+mi}{8}\PYG{+w}{ }\PYG{p}{,}\PYG{+w}{ }\PYG{n}{PG\PYGZus{}SIZE}\PYG{p}{);}
\PYG{+w}{   }\PYG{n}{user\PYGZus{}prog}\PYG{o}{\PYGZhy{}\PYGZgt{}}\PYG{n}{userprog\PYGZus{}vaddr}\PYG{p}{.}\PYG{n}{vaddr\PYGZus{}bitmap}\PYG{p}{.}\PYG{n}{bits}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{get\PYGZus{}kernel\PYGZus{}pages}\PYG{p}{(}\PYG{n}{bitmap\PYGZus{}pg\PYGZus{}cnt}\PYG{p}{);}
\PYG{+w}{   }\PYG{n}{user\PYGZus{}prog}\PYG{o}{\PYGZhy{}\PYGZgt{}}\PYG{n}{userprog\PYGZus{}vaddr}\PYG{p}{.}\PYG{n}{vaddr\PYGZus{}bitmap}\PYG{p}{.}\PYG{n}{btmp\PYGZus{}bytes\PYGZus{}len}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{(}\PYG{l+m+mh}{0xc0000000}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{n}{USER\PYGZus{}VADDR\PYGZus{}START}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{/}\PYG{+w}{ }\PYG{n}{PG\PYGZus{}SIZE}\PYG{+w}{ }\PYG{o}{/}\PYG{+w}{ }\PYG{l+m+mi}{8}\PYG{p}{;}
\PYG{+w}{   }\PYG{n}{bitmap\PYGZus{}init}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{user\PYGZus{}prog}\PYG{o}{\PYGZhy{}\PYGZgt{}}\PYG{n}{userprog\PYGZus{}vaddr}\PYG{p}{.}\PYG{n}{vaddr\PYGZus{}bitmap}\PYG{p}{);}
\PYG{p}{\PYGZcb{}}

\PYG{c+cm}{/* 创建用户进程 */}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{process\PYGZus{}execute}\PYG{p}{(}\PYG{k+kt}{void}\PYG{o}{*}\PYG{+w}{ }\PYG{n}{filename}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{char}\PYG{o}{*}\PYG{+w}{ }\PYG{n}{name}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{+w}{ }
\PYG{+w}{   }\PYG{c+cm}{/* pcb内核的数据结构,由内核来维护进程信息,因此要在内核内存池中申请 */}
\PYG{+w}{   }\PYG{k}{struct}\PYG{+w}{ }\PYG{n+nc}{task\PYGZus{}struct}\PYG{o}{*}\PYG{+w}{ }\PYG{k+kr}{thread}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{get\PYGZus{}kernel\PYGZus{}pages}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{);}
\PYG{+w}{   }\PYG{n}{init\PYGZus{}thread}\PYG{p}{(}\PYG{k+kr}{thread}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{name}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{default\PYGZus{}prio}\PYG{p}{);}\PYG{+w}{ }
\PYG{+w}{   }\PYG{n}{create\PYGZus{}user\PYGZus{}vaddr\PYGZus{}bitmap}\PYG{p}{(}\PYG{k+kr}{thread}\PYG{p}{);}
\PYG{+w}{   }\PYG{n}{thread\PYGZus{}create}\PYG{p}{(}\PYG{k+kr}{thread}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{start\PYGZus{}process}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{filename}\PYG{p}{);}
\PYG{+w}{   }\PYG{k+kr}{thread}\PYG{o}{\PYGZhy{}\PYGZgt{}}\PYG{n}{pgdir}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{create\PYGZus{}page\PYGZus{}dir}\PYG{p}{();}
\PYG{+w}{   }\PYG{n}{block\PYGZus{}desc\PYGZus{}init}\PYG{p}{(}\PYG{k+kr}{thread}\PYG{o}{\PYGZhy{}\PYGZgt{}}\PYG{n}{u\PYGZus{}block\PYGZus{}desc}\PYG{p}{);}

\PYG{+w}{   }\PYG{k}{enum}\PYG{+w}{ }\PYG{n}{intr\PYGZus{}status}\PYG{+w}{ }\PYG{n}{old\PYGZus{}status}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{intr\PYGZus{}disable}\PYG{p}{();}
\PYG{+w}{   }\PYG{n}{ASSERT}\PYG{p}{(}\PYG{o}{!}\PYG{n}{elem\PYGZus{}find}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{thread\PYGZus{}ready\PYGZus{}list}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{k+kr}{thread}\PYG{o}{\PYGZhy{}\PYGZgt{}}\PYG{n}{general\PYGZus{}tag}\PYG{p}{));}
\PYG{+w}{   }\PYG{n}{list\PYGZus{}append}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{thread\PYGZus{}ready\PYGZus{}list}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{k+kr}{thread}\PYG{o}{\PYGZhy{}\PYGZgt{}}\PYG{n}{general\PYGZus{}tag}\PYG{p}{);}

\PYG{+w}{   }\PYG{n}{ASSERT}\PYG{p}{(}\PYG{o}{!}\PYG{n}{elem\PYGZus{}find}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{thread\PYGZus{}all\PYGZus{}list}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{k+kr}{thread}\PYG{o}{\PYGZhy{}\PYGZgt{}}\PYG{n}{all\PYGZus{}list\PYGZus{}tag}\PYG{p}{));}
\PYG{+w}{   }\PYG{n}{list\PYGZus{}append}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{thread\PYGZus{}all\PYGZus{}list}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{k+kr}{thread}\PYG{o}{\PYGZhy{}\PYGZgt{}}\PYG{n}{all\PYGZus{}list\PYGZus{}tag}\PYG{p}{);}
\PYG{+w}{   }\PYG{n}{intr\PYGZus{}set\PYGZus{}status}\PYG{p}{(}\PYG{n}{old\PYGZus{}status}\PYG{p}{);}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}
