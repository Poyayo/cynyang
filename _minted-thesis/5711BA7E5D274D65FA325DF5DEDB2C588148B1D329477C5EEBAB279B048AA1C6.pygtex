\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+c1}{;\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{+w}{			   }\PYG{c+c1}{;功能:读取硬盘n个扇区}
\PYG{n+nl}{rd\PYGZus{}disk\PYGZus{}m\PYGZus{}32:}\PYG{+w}{	   }
\PYG{c+c1}{;\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{+w}{							 }\PYG{c+c1}{; eax=LBA扇区号}
\PYG{+w}{							 }\PYG{c+c1}{; ebx=将数据写入的内存地址}
\PYG{+w}{							 }\PYG{c+c1}{; ecx=读入的扇区数}
\PYG{+w}{      }\PYG{n+nf}{mov}\PYG{+w}{ }\PYG{n+nb}{esi}\PYG{p}{,}\PYG{n+nb}{eax}\PYG{+w}{	   }\PYG{c+c1}{; 备份eax}
\PYG{+w}{      }\PYG{n+nf}{mov}\PYG{+w}{ }\PYG{n+nb}{di}\PYG{p}{,}\PYG{n+nb}{cx}\PYG{+w}{		   }\PYG{c+c1}{; 备份扇区数到di}
\PYG{c+c1}{;读写硬盘:}
\PYG{c+c1}{;第1步：设置要读取的扇区数}
\PYG{+w}{      }\PYG{n+nf}{mov}\PYG{+w}{ }\PYG{n+nb}{dx}\PYG{p}{,}\PYG{l+m+mh}{0x1f2}
\PYG{+w}{      }\PYG{n+nf}{mov}\PYG{+w}{ }\PYG{n+nb}{al}\PYG{p}{,}\PYG{n+nb}{cl}
\PYG{+w}{      }\PYG{n+nf}{out}\PYG{+w}{ }\PYG{n+nb}{dx}\PYG{p}{,}\PYG{n+nb}{al}\PYG{+w}{            }\PYG{c+c1}{;读取的扇区数}

\PYG{+w}{      }\PYG{n+nf}{mov}\PYG{+w}{ }\PYG{n+nb}{eax}\PYG{p}{,}\PYG{n+nb}{esi}\PYG{+w}{	   }\PYG{c+c1}{;恢复ax}

\PYG{c+c1}{;第2步：将LBA地址存入0x1f3 \PYGZti{} 0x1f6}

\PYG{+w}{      }\PYG{c+c1}{;LBA地址7\PYGZti{}0位写入端口0x1f3}
\PYG{+w}{      }\PYG{n+nf}{mov}\PYG{+w}{ }\PYG{n+nb}{dx}\PYG{p}{,}\PYG{l+m+mh}{0x1f3}\PYG{+w}{                       }
\PYG{+w}{      }\PYG{n+nf}{out}\PYG{+w}{ }\PYG{n+nb}{dx}\PYG{p}{,}\PYG{n+nb}{al}\PYG{+w}{                          }

\PYG{+w}{      }\PYG{c+c1}{;LBA地址15\PYGZti{}8位写入端口0x1f4}
\PYG{+w}{      }\PYG{n+nf}{mov}\PYG{+w}{ }\PYG{n+nb}{cl}\PYG{p}{,}\PYG{l+m+mi}{8}
\PYG{+w}{      }\PYG{n+nf}{shr}\PYG{+w}{ }\PYG{n+nb}{eax}\PYG{p}{,}\PYG{n+nb}{cl}
\PYG{+w}{      }\PYG{n+nf}{mov}\PYG{+w}{ }\PYG{n+nb}{dx}\PYG{p}{,}\PYG{l+m+mh}{0x1f4}
\PYG{+w}{      }\PYG{n+nf}{out}\PYG{+w}{ }\PYG{n+nb}{dx}\PYG{p}{,}\PYG{n+nb}{al}

\PYG{+w}{      }\PYG{c+c1}{;LBA地址23\PYGZti{}16位写入端口0x1f5}
\PYG{+w}{      }\PYG{n+nf}{shr}\PYG{+w}{ }\PYG{n+nb}{eax}\PYG{p}{,}\PYG{n+nb}{cl}
\PYG{+w}{      }\PYG{n+nf}{mov}\PYG{+w}{ }\PYG{n+nb}{dx}\PYG{p}{,}\PYG{l+m+mh}{0x1f5}
\PYG{+w}{      }\PYG{n+nf}{out}\PYG{+w}{ }\PYG{n+nb}{dx}\PYG{p}{,}\PYG{n+nb}{al}

\PYG{+w}{      }\PYG{n+nf}{shr}\PYG{+w}{ }\PYG{n+nb}{eax}\PYG{p}{,}\PYG{n+nb}{cl}
\PYG{+w}{      }\PYG{n+nf}{and}\PYG{+w}{ }\PYG{n+nb}{al}\PYG{p}{,}\PYG{l+m+mh}{0x0f}\PYG{+w}{	   }\PYG{c+c1}{;lba第24\PYGZti{}27位}
\PYG{+w}{      }\PYG{n+nf}{or}\PYG{+w}{ }\PYG{n+nb}{al}\PYG{p}{,}\PYG{l+m+mh}{0xe0}\PYG{+w}{	   }\PYG{c+c1}{; 设置7～4位为1110,表示lba模式}
\PYG{+w}{      }\PYG{n+nf}{mov}\PYG{+w}{ }\PYG{n+nb}{dx}\PYG{p}{,}\PYG{l+m+mh}{0x1f6}
\PYG{+w}{      }\PYG{n+nf}{out}\PYG{+w}{ }\PYG{n+nb}{dx}\PYG{p}{,}\PYG{n+nb}{al}

\PYG{c+c1}{;第3步：向0x1f7端口写入读命令，0x20 }
\PYG{+w}{      }\PYG{n+nf}{mov}\PYG{+w}{ }\PYG{n+nb}{dx}\PYG{p}{,}\PYG{l+m+mh}{0x1f7}
\PYG{+w}{      }\PYG{n+nf}{mov}\PYG{+w}{ }\PYG{n+nb}{al}\PYG{p}{,}\PYG{l+m+mh}{0x20}\PYG{+w}{                        }
\PYG{+w}{      }\PYG{n+nf}{out}\PYG{+w}{ }\PYG{n+nb}{dx}\PYG{p}{,}\PYG{n+nb}{al}

\PYG{c+c1}{;;;;;;; 至此,硬盘控制器便从指定的lba地址(eax)处,读出连续的cx个扇区,下面检查硬盘状态,不忙就能把这cx个扇区的数据读出来}

\PYG{c+c1}{;第4步：检测硬盘状态}
\PYG{+w}{  }\PYG{n+nl}{.not\PYGZus{}ready:}\PYG{+w}{		   }\PYG{c+c1}{;测试0x1f7端口(status寄存器)的的BSY位}
\PYG{+w}{      }\PYG{c+c1}{;同一端口,写时表示写入命令字,读时表示读入硬盘状态}
\PYG{+w}{      }\PYG{n+nf}{nop}
\PYG{+w}{      }\PYG{n+nf}{in}\PYG{+w}{ }\PYG{n+nb}{al}\PYG{p}{,}\PYG{n+nb}{dx}
\PYG{+w}{      }\PYG{n+nf}{and}\PYG{+w}{ }\PYG{n+nb}{al}\PYG{p}{,}\PYG{l+m+mh}{0x88}\PYG{+w}{	   }\PYG{c+c1}{;第4位为1表示硬盘控制器已准备好数据传输,第7位为1表示硬盘忙}
\PYG{+w}{      }\PYG{n+nf}{cmp}\PYG{+w}{ }\PYG{n+nb}{al}\PYG{p}{,}\PYG{l+m+mh}{0x08}
\PYG{+w}{      }\PYG{n+nf}{jnz}\PYG{+w}{ }\PYG{n+nv}{.not\PYGZus{}ready}\PYG{+w}{	   }\PYG{c+c1}{;若未准备好,继续等。}

\PYG{c+c1}{;第5步：从0x1f0端口读数据}
\PYG{+w}{      }\PYG{n+nf}{mov}\PYG{+w}{ }\PYG{n+nb}{ax}\PYG{p}{,}\PYG{+w}{ }\PYG{n+nb}{di}\PYG{+w}{	   }\PYG{c+c1}{;以下从硬盘端口读数据用insw指令更快捷,不过尽可能多的演示命令使用,}
\PYG{+w}{			   }\PYG{c+c1}{;在此先用这种方法,在后面内容会用到insw和outsw等}

\PYG{+w}{      }\PYG{n+nf}{mov}\PYG{+w}{ }\PYG{n+nb}{dx}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{256}\PYG{+w}{	   }\PYG{c+c1}{;di为要读取的扇区数,一个扇区有512字节,每次读入一个字,共需di*512/2次,所以di*256}
\PYG{+w}{      }\PYG{n+nf}{mul}\PYG{+w}{ }\PYG{n+nb}{dx}
\PYG{+w}{      }\PYG{n+nf}{mov}\PYG{+w}{ }\PYG{n+nb}{cx}\PYG{p}{,}\PYG{+w}{ }\PYG{n+nb}{ax}\PYG{+w}{	   }
\PYG{+w}{      }\PYG{n+nf}{mov}\PYG{+w}{ }\PYG{n+nb}{dx}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mh}{0x1f0}
\PYG{+w}{  }\PYG{n+nl}{.go\PYGZus{}on\PYGZus{}read:}
\PYG{+w}{      }\PYG{n+nf}{in}\PYG{+w}{ }\PYG{n+nb}{ax}\PYG{p}{,}\PYG{n+nb}{dx}\PYG{+w}{		}
\PYG{+w}{      }\PYG{n+nf}{mov}\PYG{+w}{ }\PYG{p}{[}\PYG{n+nb}{ebx}\PYG{p}{],}\PYG{+w}{ }\PYG{n+nb}{ax}
\PYG{+w}{      }\PYG{n+nf}{add}\PYG{+w}{ }\PYG{n+nb}{ebx}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{2}
\PYG{+w}{			  }\PYG{c+c1}{; 由于在实模式下偏移地址为16位,所以用bx只会访问到0\PYGZti{}FFFFh的偏移。}
\PYG{+w}{			  }\PYG{c+c1}{; loader的栈指针为0x900,bx为指向的数据输出缓冲区,且为16位，}
\PYG{+w}{			  }\PYG{c+c1}{; 超过0xffff后,bx部分会从0开始,所以当要读取的扇区数过大,待写入的地址超过bx的范围时，}
\PYG{+w}{			  }\PYG{c+c1}{; 从硬盘上读出的数据会把0x0000\PYGZti{}0xffff的覆盖，}
\PYG{+w}{			  }\PYG{c+c1}{; 造成栈被破坏,所以ret返回时,返回地址被破坏了,已经不是之前正确的地址,}
\PYG{+w}{			  }\PYG{c+c1}{; 故程序出会错,不知道会跑到哪里去。}
\PYG{+w}{			  }\PYG{c+c1}{; 所以改为ebx代替bx指向缓冲区,这样生成的机器码前面会有0x66和0x67来反转。}
\PYG{+w}{			  }\PYG{c+c1}{; 0X66用于反转默认的操作数大小! 0X67用于反转默认的寻址方式.}
\PYG{+w}{			  }\PYG{c+c1}{; cpu处于16位模式时,会理所当然的认为操作数和寻址都是16位,处于32位模式时,}
\PYG{+w}{			  }\PYG{c+c1}{; 也会认为要执行的指令是32位.}
\PYG{+w}{			  }\PYG{c+c1}{; 当我们在其中任意模式下用了另外模式的寻址方式或操作数大小(姑且认为16位模式用16位字节操作数，}
\PYG{+w}{			  }\PYG{c+c1}{; 32位模式下用32字节的操作数)时,编译器会在指令前帮我们加上0x66或0x67，}
\PYG{+w}{			  }\PYG{c+c1}{; 临时改变当前cpu模式到另外的模式下.}
\PYG{+w}{			  }\PYG{c+c1}{; 假设当前运行在16位模式,遇到0X66时,操作数大小变为32位.}
\PYG{+w}{			  }\PYG{c+c1}{; 假设当前运行在32位模式,遇到0X66时,操作数大小变为16位.}
\PYG{+w}{			  }\PYG{c+c1}{; 假设当前运行在16位模式,遇到0X67时,寻址方式变为32位寻址}
\PYG{+w}{			  }\PYG{c+c1}{; 假设当前运行在32位模式,遇到0X67时,寻址方式变为16位寻址.}

\PYG{+w}{      }\PYG{n+nf}{loop}\PYG{+w}{ }\PYG{n+nv}{.go\PYGZus{}on\PYGZus{}read}
\PYG{+w}{      }\PYG{n+nf}{ret}
\end{Verbatim}
