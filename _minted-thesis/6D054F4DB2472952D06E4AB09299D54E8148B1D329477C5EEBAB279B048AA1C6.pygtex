\begin{Verbatim}[commandchars=\\\{\}]
\PYG{+w}{   }\PYG{n+nf}{xor}\PYG{+w}{ }\PYG{n+nb}{ebx}\PYG{p}{,}\PYG{+w}{ }\PYG{n+nb}{ebx}\PYG{+w}{		      }\PYG{c+c1}{;第一次调用时，ebx值要为0}
\PYG{+w}{   }\PYG{n+nf}{mov}\PYG{+w}{ }\PYG{n+nb}{edx}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mh}{0x534d4150}\PYG{+w}{	      }\PYG{c+c1}{;edx只赋值一次，循环体中不会改变}
\PYG{+w}{   }\PYG{n+nf}{mov}\PYG{+w}{ }\PYG{n+nb}{di}\PYG{p}{,}\PYG{+w}{ }\PYG{n+nv}{ards\PYGZus{}buf}\PYG{+w}{	      }\PYG{c+c1}{;ards结构缓冲区}
\PYG{n+nl}{.e820\PYGZus{}mem\PYGZus{}get\PYGZus{}loop:}\PYG{+w}{	      }\PYG{c+c1}{;循环获取每个ARDS内存范围描述结构}
\PYG{+w}{   }\PYG{n+nf}{mov}\PYG{+w}{ }\PYG{n+nb}{eax}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mh}{0x0000e820}\PYG{+w}{	      }\PYG{c+c1}{;执行int 0x15后,eax值变为0x534d4150,所以每次执行int前都要更新为子功能号。}
\PYG{+w}{   }\PYG{n+nf}{mov}\PYG{+w}{ }\PYG{n+nb}{ecx}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{20}\PYG{+w}{		      }\PYG{c+c1}{;ARDS地址范围描述符结构大小是20字节}
\PYG{+w}{   }\PYG{n+nf}{int}\PYG{+w}{ }\PYG{l+m+mh}{0x15}
\PYG{+w}{   }\PYG{n+nf}{jc}\PYG{+w}{ }\PYG{n+nv}{.e820\PYGZus{}failed\PYGZus{}so\PYGZus{}try\PYGZus{}e801}\PYG{+w}{   }\PYG{c+c1}{;若cf位为1则有错误发生，尝试0xe801子功能}
\PYG{+w}{   }\PYG{n+nf}{add}\PYG{+w}{ }\PYG{n+nb}{di}\PYG{p}{,}\PYG{+w}{ }\PYG{n+nb}{cx}\PYG{+w}{		      }\PYG{c+c1}{;使di增加20字节指向缓冲区中新的ARDS结构位置}
\PYG{+w}{   }\PYG{n+nf}{inc}\PYG{+w}{ }\PYG{k+kt}{word}\PYG{+w}{ }\PYG{p}{[}\PYG{n+nv}{ards\PYGZus{}nr}\PYG{p}{]}\PYG{+w}{	      }\PYG{c+c1}{;记录ARDS数量}
\PYG{+w}{   }\PYG{n+nf}{cmp}\PYG{+w}{ }\PYG{n+nb}{ebx}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{+w}{		      }\PYG{c+c1}{;若ebx为0且cf不为1,这说明ards全部返回，当前已是最后一个}
\PYG{+w}{   }\PYG{n+nf}{jnz}\PYG{+w}{ }\PYG{n+nv}{.e820\PYGZus{}mem\PYGZus{}get\PYGZus{}loop}

\PYG{c+c1}{;在所有ards结构中，找出(base\PYGZus{}add\PYGZus{}low + length\PYGZus{}low)的最大值，即内存的容量。}
\PYG{+w}{   }\PYG{n+nf}{mov}\PYG{+w}{ }\PYG{n+nb}{cx}\PYG{p}{,}\PYG{+w}{ }\PYG{p}{[}\PYG{n+nv}{ards\PYGZus{}nr}\PYG{p}{]}\PYG{+w}{	      }\PYG{c+c1}{;遍历每一个ARDS结构体,循环次数是ARDS的数量}
\PYG{+w}{   }\PYG{n+nf}{mov}\PYG{+w}{ }\PYG{n+nb}{ebx}\PYG{p}{,}\PYG{+w}{ }\PYG{n+nv}{ards\PYGZus{}buf}\PYG{+w}{ }
\PYG{+w}{   }\PYG{n+nf}{xor}\PYG{+w}{ }\PYG{n+nb}{edx}\PYG{p}{,}\PYG{+w}{ }\PYG{n+nb}{edx}\PYG{+w}{		      }\PYG{c+c1}{;edx为最大的内存容量,在此先清0}
\PYG{n+nl}{.find\PYGZus{}max\PYGZus{}mem\PYGZus{}area:}\PYG{+w}{	      }\PYG{c+c1}{;无须判断type是否为1,最大的内存块一定是可被使用}
\PYG{+w}{   }\PYG{n+nf}{mov}\PYG{+w}{ }\PYG{n+nb}{eax}\PYG{p}{,}\PYG{+w}{ }\PYG{p}{[}\PYG{n+nb}{ebx}\PYG{p}{]}\PYG{+w}{	      }\PYG{c+c1}{;base\PYGZus{}add\PYGZus{}low}
\PYG{+w}{   }\PYG{n+nf}{add}\PYG{+w}{ }\PYG{n+nb}{eax}\PYG{p}{,}\PYG{+w}{ }\PYG{p}{[}\PYG{n+nb}{ebx}\PYG{o}{+}\PYG{l+m+mi}{8}\PYG{p}{]}\PYG{+w}{	      }\PYG{c+c1}{;length\PYGZus{}low}
\PYG{+w}{   }\PYG{n+nf}{add}\PYG{+w}{ }\PYG{n+nb}{ebx}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{20}\PYG{+w}{		      }\PYG{c+c1}{;指向缓冲区中下一个ARDS结构}
\PYG{+w}{   }\PYG{n+nf}{cmp}\PYG{+w}{ }\PYG{n+nb}{edx}\PYG{p}{,}\PYG{+w}{ }\PYG{n+nb}{eax}\PYG{+w}{		      }\PYG{c+c1}{;冒泡排序，找出最大,edx寄存器始终是最大的内存容量}
\PYG{+w}{   }\PYG{n+nf}{jge}\PYG{+w}{ }\PYG{n+nv}{.next\PYGZus{}ards}
\PYG{+w}{   }\PYG{n+nf}{mov}\PYG{+w}{ }\PYG{n+nb}{edx}\PYG{p}{,}\PYG{+w}{ }\PYG{n+nb}{eax}\PYG{+w}{		      }\PYG{c+c1}{;edx为总内存大小}
\PYG{n+nl}{.next\PYGZus{}ards:}
\PYG{+w}{   }\PYG{n+nf}{loop}\PYG{+w}{ }\PYG{n+nv}{.find\PYGZus{}max\PYGZus{}mem\PYGZus{}area}
\PYG{+w}{   }\PYG{n+nf}{jmp}\PYG{+w}{ }\PYG{n+nv}{.mem\PYGZus{}get\PYGZus{}ok}
\end{Verbatim}
