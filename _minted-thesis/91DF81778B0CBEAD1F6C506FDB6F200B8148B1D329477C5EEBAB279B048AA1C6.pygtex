\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{global}\PYG{+w}{ }\PYG{n+nv}{put\PYGZus{}int}
\PYG{n+nl}{put\PYGZus{}int:}
\PYG{+w}{   }\PYG{n+nf}{pushad}
\PYG{+w}{   }\PYG{n+nf}{mov}\PYG{+w}{ }\PYG{n+nb}{ebp}\PYG{p}{,}\PYG{+w}{ }\PYG{n+nb}{esp}
\PYG{+w}{   }\PYG{n+nf}{mov}\PYG{+w}{ }\PYG{n+nb}{eax}\PYG{p}{,}\PYG{+w}{ }\PYG{p}{[}\PYG{n+nb}{ebp}\PYG{o}{+}\PYG{l+m+mi}{4}\PYG{o}{*}\PYG{l+m+mi}{9}\PYG{p}{]}\PYG{+w}{		       }\PYG{c+c1}{; call的返回地址占4字节+pushad的8个4字节}
\PYG{+w}{   }\PYG{n+nf}{mov}\PYG{+w}{ }\PYG{n+nb}{edx}\PYG{p}{,}\PYG{+w}{ }\PYG{n+nb}{eax}
\PYG{+w}{   }\PYG{n+nf}{mov}\PYG{+w}{ }\PYG{n+nb}{edi}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{7}\PYG{+w}{                          }\PYG{c+c1}{; 指定在put\PYGZus{}int\PYGZus{}buffer中初始的偏移量}
\PYG{+w}{   }\PYG{n+nf}{mov}\PYG{+w}{ }\PYG{n+nb}{ecx}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{8}\PYG{+w}{			       }\PYG{c+c1}{; 32位数字中,16进制数字的位数是8个}
\PYG{+w}{   }\PYG{n+nf}{mov}\PYG{+w}{ }\PYG{n+nb}{ebx}\PYG{p}{,}\PYG{+w}{ }\PYG{n+nv}{put\PYGZus{}int\PYGZus{}buffer}

\PYG{c+c1}{;将32位数字按照16进制的形式从低位到高位逐个处理,共处理8个16进制数字}
\PYG{n+nl}{.16based\PYGZus{}4bits:}\PYG{+w}{			       }\PYG{c+c1}{; 每4位二进制是16进制数字的1位,遍历每一位16进制数字}
\PYG{+w}{   }\PYG{n+nf}{and}\PYG{+w}{ }\PYG{n+nb}{edx}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mh}{0x0000000F}\PYG{+w}{		       }\PYG{c+c1}{; 解析16进制数字的每一位。and与操作后,edx只有低4位有效}
\PYG{+w}{   }\PYG{n+nf}{cmp}\PYG{+w}{ }\PYG{n+nb}{edx}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{9}\PYG{+w}{			       }\PYG{c+c1}{; 数字0～9和a\PYGZti{}f需要分别处理成对应的字符}
\PYG{+w}{   }\PYG{n+nf}{jg}\PYG{+w}{ }\PYG{n+nv}{.is\PYGZus{}A2F}\PYG{+w}{ }
\PYG{+w}{   }\PYG{n+nf}{add}\PYG{+w}{ }\PYG{n+nb}{edx}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZsq{}0\PYGZsq{}}\PYG{+w}{			       }\PYG{c+c1}{; ascii码是8位大小。add求和操作后,edx低8位有效。}
\PYG{+w}{   }\PYG{n+nf}{jmp}\PYG{+w}{ }\PYG{n+nv}{.store}
\PYG{n+nl}{.is\PYGZus{}A2F:}
\PYG{+w}{   }\PYG{n+nf}{sub}\PYG{+w}{ }\PYG{n+nb}{edx}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{10}\PYG{+w}{			       }\PYG{c+c1}{; A\PYGZti{}F 减去10 所得到的差,再加上字符A的ascii码,便是A\PYGZti{}F对应的ascii码}
\PYG{+w}{   }\PYG{n+nf}{add}\PYG{+w}{ }\PYG{n+nb}{edx}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZsq{}A\PYGZsq{}}

\PYG{c+c1}{;将每一位数字转换成对应的字符后,按照类似“大端”的顺序存储到缓冲区put\PYGZus{}int\PYGZus{}buffer}
\PYG{c+c1}{;高位字符放在低地址,低位字符要放在高地址,这样和大端字节序类似,只不过咱们这里是字符序.}
\PYG{n+nl}{.store:}
\PYG{c+c1}{; 此时dl中应该是数字对应的字符的ascii码}
\PYG{+w}{   }\PYG{n+nf}{mov}\PYG{+w}{ }\PYG{p}{[}\PYG{n+nb}{ebx}\PYG{o}{+}\PYG{n+nb}{edi}\PYG{p}{],}\PYG{+w}{ }\PYG{n+nb}{dl}\PYG{+w}{		       }
\PYG{+w}{   }\PYG{n+nf}{dec}\PYG{+w}{ }\PYG{n+nb}{edi}
\PYG{+w}{   }\PYG{n+nf}{shr}\PYG{+w}{ }\PYG{n+nb}{eax}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{4}
\PYG{+w}{   }\PYG{n+nf}{mov}\PYG{+w}{ }\PYG{n+nb}{edx}\PYG{p}{,}\PYG{+w}{ }\PYG{n+nb}{eax}\PYG{+w}{ }
\PYG{+w}{   }\PYG{n+nf}{loop}\PYG{+w}{ }\PYG{n+nv}{.16based\PYGZus{}4bits}

\PYG{c+c1}{;现在put\PYGZus{}int\PYGZus{}buffer中已全是字符,打印之前,}
\PYG{c+c1}{;把高位连续的字符去掉,比如把字符000123变成123}
\PYG{n+nl}{.ready\PYGZus{}to\PYGZus{}print:}
\PYG{+w}{   }\PYG{n+nf}{inc}\PYG{+w}{ }\PYG{n+nb}{edi}\PYG{+w}{			       }\PYG{c+c1}{; 此时edi退减为\PYGZhy{}1(0xffffffff),加1使其为0}
\PYG{n+nl}{.skip\PYGZus{}prefix\PYGZus{}0:}\PYG{+w}{  }
\PYG{+w}{   }\PYG{n+nf}{cmp}\PYG{+w}{ }\PYG{n+nb}{edi}\PYG{p}{,}\PYG{l+m+mi}{8}\PYG{+w}{			       }\PYG{c+c1}{; 若已经比较第9个字符了，表示待打印的字符串为全0 }
\PYG{+w}{   }\PYG{n+nf}{je}\PYG{+w}{ }\PYG{n+nv}{.full0}\PYG{+w}{ }
\PYG{c+c1}{;找出连续的0字符, edi做为非0的最高位字符的偏移}
\PYG{n+nl}{.go\PYGZus{}on\PYGZus{}skip:}\PYG{+w}{   }
\PYG{+w}{   }\PYG{n+nf}{mov}\PYG{+w}{ }\PYG{n+nb}{cl}\PYG{p}{,}\PYG{+w}{ }\PYG{p}{[}\PYG{n+nv}{put\PYGZus{}int\PYGZus{}buffer}\PYG{o}{+}\PYG{n+nb}{edi}\PYG{p}{]}
\PYG{+w}{   }\PYG{n+nf}{inc}\PYG{+w}{ }\PYG{n+nb}{edi}
\PYG{+w}{   }\PYG{n+nf}{cmp}\PYG{+w}{ }\PYG{n+nb}{cl}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZsq{}0\PYGZsq{}}\PYG{+w}{ }
\PYG{+w}{   }\PYG{n+nf}{je}\PYG{+w}{ }\PYG{n+nv}{.skip\PYGZus{}prefix\PYGZus{}0}\PYG{+w}{		       }\PYG{c+c1}{; 继续判断下一位字符是否为字符0(不是数字0)}
\PYG{+w}{   }\PYG{n+nf}{dec}\PYG{+w}{ }\PYG{n+nb}{edi}\PYG{+w}{			       }\PYG{c+c1}{;edi在上面的inc操作中指向了下一个字符,若当前字符不为\PYGZsq{}0\PYGZsq{},要恢复edi指向当前字符		       }
\PYG{+w}{   }\PYG{n+nf}{jmp}\PYG{+w}{ }\PYG{n+nv}{.put\PYGZus{}each\PYGZus{}num}

\PYG{n+nl}{.full0:}
\PYG{+w}{   }\PYG{n+nf}{mov}\PYG{+w}{ }\PYG{n+nb}{cl}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}0\PYGZsq{}}\PYG{+w}{			       }\PYG{c+c1}{; 输入的数字为全0时，则只打印0}
\PYG{n+nl}{.put\PYGZus{}each\PYGZus{}num:}
\PYG{+w}{   }\PYG{n+nf}{push}\PYG{+w}{ }\PYG{n+nb}{ecx}\PYG{+w}{			       }\PYG{c+c1}{; 此时cl中为可打印的字符}
\PYG{+w}{   }\PYG{n+nf}{call}\PYG{+w}{ }\PYG{n+nv}{put\PYGZus{}char}
\PYG{+w}{   }\PYG{n+nf}{add}\PYG{+w}{ }\PYG{n+nb}{esp}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{4}
\PYG{+w}{   }\PYG{n+nf}{inc}\PYG{+w}{ }\PYG{n+nb}{edi}\PYG{+w}{			       }\PYG{c+c1}{; 使edi指向下一个字符}
\PYG{+w}{   }\PYG{n+nf}{mov}\PYG{+w}{ }\PYG{n+nb}{cl}\PYG{p}{,}\PYG{+w}{ }\PYG{p}{[}\PYG{n+nv}{put\PYGZus{}int\PYGZus{}buffer}\PYG{o}{+}\PYG{n+nb}{edi}\PYG{p}{]}\PYG{+w}{	       }\PYG{c+c1}{; 获取下一个字符到cl寄存器}
\PYG{+w}{   }\PYG{n+nf}{cmp}\PYG{+w}{ }\PYG{n+nb}{edi}\PYG{p}{,}\PYG{l+m+mi}{8}
\PYG{+w}{   }\PYG{n+nf}{jl}\PYG{+w}{ }\PYG{n+nv}{.put\PYGZus{}each\PYGZus{}num}
\PYG{+w}{   }\PYG{n+nf}{popad}
\PYG{+w}{   }\PYG{n+nf}{ret}
\end{Verbatim}
