\begin{Verbatim}[commandchars=\\\{\}]
\PYG{+w}{   }\PYG{n+nf}{push}\PYG{+w}{ }\PYG{n+nb}{ebx}
\PYG{+w}{   }\PYG{n+nf}{push}\PYG{+w}{ }\PYG{n+nb}{ecx}
\PYG{+w}{   }\PYG{n+nf}{xor}\PYG{+w}{ }\PYG{n+nb}{ecx}\PYG{p}{,}\PYG{+w}{ }\PYG{n+nb}{ecx}\PYG{+w}{		      }\PYG{c+c1}{; 准备用ecx存储参数,清空}
\PYG{+w}{   }\PYG{n+nf}{mov}\PYG{+w}{ }\PYG{n+nb}{ebx}\PYG{p}{,}\PYG{+w}{ }\PYG{p}{[}\PYG{n+nb}{esp}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+m+mi}{12}\PYG{p}{]}\PYG{+w}{	      }\PYG{c+c1}{; 从栈中得到待打印的字符串地址}
\PYG{n+nl}{.goon:}
\PYG{+w}{   }\PYG{n+nf}{mov}\PYG{+w}{ }\PYG{n+nb}{cl}\PYG{p}{,}\PYG{+w}{ }\PYG{p}{[}\PYG{n+nb}{ebx}\PYG{p}{]}
\PYG{+w}{   }\PYG{n+nf}{cmp}\PYG{+w}{ }\PYG{n+nb}{cl}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{+w}{		      }\PYG{c+c1}{; 如果处理到了字符串尾,跳到结束处返回}
\PYG{+w}{   }\PYG{n+nf}{jz}\PYG{+w}{ }\PYG{n+nv}{.str\PYGZus{}over}
\PYG{+w}{   }\PYG{n+nf}{push}\PYG{+w}{ }\PYG{n+nb}{ecx}\PYG{+w}{		      }\PYG{c+c1}{; 为put\PYGZus{}char函数传递参数}
\PYG{+w}{   }\PYG{n+nf}{call}\PYG{+w}{ }\PYG{n+nv}{put\PYGZus{}char}
\PYG{+w}{   }\PYG{n+nf}{add}\PYG{+w}{ }\PYG{n+nb}{esp}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{4}\PYG{+w}{		      }\PYG{c+c1}{; 回收参数所占的栈空间}
\PYG{+w}{   }\PYG{n+nf}{inc}\PYG{+w}{ }\PYG{n+nb}{ebx}\PYG{+w}{		      }\PYG{c+c1}{; 使ebx指向下一个字符}
\PYG{+w}{   }\PYG{n+nf}{jmp}\PYG{+w}{ }\PYG{n+nv}{.goon}
\PYG{n+nl}{.str\PYGZus{}over:}
\PYG{+w}{   }\PYG{n+nf}{pop}\PYG{+w}{ }\PYG{n+nb}{ecx}
\PYG{+w}{   }\PYG{n+nf}{pop}\PYG{+w}{ }\PYG{n+nb}{ebx}
\PYG{+w}{   }\PYG{n+nf}{ret}
\end{Verbatim}
