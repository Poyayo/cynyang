\begin{Verbatim}[commandchars=\\\{\}]
\PYG{+w}{   }\PYG{n+nf}{mov}\PYG{+w}{ }\PYG{n+nb}{al}\PYG{p}{,}\PYG{l+m+mh}{0x20}\PYG{+w}{                   }\PYG{c+c1}{; 中断结束命令EOI}
\PYG{+w}{   }\PYG{n+nf}{out}\PYG{+w}{ }\PYG{l+m+mh}{0xa0}\PYG{p}{,}\PYG{n+nb}{al}\PYG{+w}{                   }\PYG{c+c1}{; 向从片发送}
\PYG{+w}{   }\PYG{n+nf}{out}\PYG{+w}{ }\PYG{l+m+mh}{0x20}\PYG{p}{,}\PYG{n+nb}{al}\PYG{+w}{                   }\PYG{c+c1}{; 向主片发送}

\PYG{+w}{   }\PYG{n+nf}{push}\PYG{+w}{ }\PYG{o}{\PYGZpc{}}\PYG{l+m+mi}{1}\PYG{+w}{			 }\PYG{c+c1}{; 不管idt\PYGZus{}table中的目标程序是否需要参数,都一律压入中断向量号,调试时很方便}
\PYG{+w}{   }\PYG{n+nf}{call}\PYG{+w}{ }\PYG{p}{[}\PYG{n+nv}{idt\PYGZus{}table}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{o}{\PYGZpc{}}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{+w}{       }\PYG{c+c1}{; 调用idt\PYGZus{}table中的C版本中断处理函数}
\PYG{+w}{   }\PYG{n+nf}{jmp}\PYG{+w}{ }\PYG{n+nv}{intr\PYGZus{}exit}

\PYG{k}{section}\PYG{+w}{ }\PYG{n+nv}{.data}
\PYG{+w}{   }\PYG{k+kd}{dd}\PYG{+w}{    }\PYG{n+nv}{intr}\PYG{o}{\PYGZpc{}}\PYG{l+m+mi}{1}\PYG{n+nv}{entry}\PYG{+w}{	 }\PYG{c+c1}{; 存储各个中断入口程序的地址，形成intr\PYGZus{}entry\PYGZus{}table数组}
\PYG{c+cp}{\PYGZpc{}endmacro}

\PYG{k}{section}\PYG{+w}{ }\PYG{n+nv}{.text}
\PYG{k}{global}\PYG{+w}{ }\PYG{n+nv}{intr\PYGZus{}exit}
\PYG{n+nl}{intr\PYGZus{}exit:}\PYG{+w}{	     }
\PYG{c+c1}{; 以下是恢复上下文环境}
\PYG{+w}{   }\PYG{n+nf}{add}\PYG{+w}{ }\PYG{n+nb}{esp}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{4}\PYG{+w}{			   }\PYG{c+c1}{; 跳过中断号}
\PYG{+w}{   }\PYG{n+nf}{popad}
\PYG{+w}{   }\PYG{n+nf}{pop}\PYG{+w}{ }\PYG{n+nb}{gs}
\PYG{+w}{   }\PYG{n+nf}{pop}\PYG{+w}{ }\PYG{n+nb}{fs}
\PYG{+w}{   }\PYG{n+nf}{pop}\PYG{+w}{ }\PYG{n+nb}{es}
\PYG{+w}{   }\PYG{n+nf}{pop}\PYG{+w}{ }\PYG{n+nb}{ds}
\PYG{+w}{   }\PYG{n+nf}{add}\PYG{+w}{ }\PYG{n+nb}{esp}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{4}\PYG{+w}{			   }\PYG{c+c1}{; 跳过error\PYGZus{}code}
\PYG{+w}{   }\PYG{n+nf}{iretd}
\end{Verbatim}
